import os

import numpy as np
import pandas as pd
from datafold.appfold import EDMD
from datafold.dynfold import TSCRadialBasis, TSCIdentity
from datafold.pcfold import TSCDataFrame
from sklearn.cluster import KMeans

from dataset import load, generate_sample_points
from plotting import plot_basins
from thin_plate_kernel import ThinPlateKernel

kernel_centre_prefix = '../data/kernel_centers'
results_prefix = '../data/results'


def approximate_koopman(data_name, set_of_interest_dimension_bounds, dataset, num_centers=500, delta=1e-3):
    """
    Approximate the Koopman operator of a dynamical system using EDMD. If the centres of the thin plate rbfs already
    exist, they will be loaded.

    :param data_name:                           str, Name of the dataset
    :param set_of_interest_dimension_bounds:    [(lower_bound, upper_bound)], Bounds of the set of interest on which the
                                                                                algorithm will be approximated.
    :param dataset:                             TSCDataFrame, Dataset generated by the dynamical system.
    :param num_centers:                         int, Number of centers for the RBFs
    :param delta:                               float, Delta used for thin plate kernels.
    :return:                                    EDMD, Approximation of the Koopman operator using EDMD
    """
    # Load or generate and save the centers for the thin plate kernels
    centres_path = os.path.join(kernel_centre_prefix,
                                data_name + '_dimension_bounds:' + str(set_of_interest_dimension_bounds) + '.csv')
    if os.path.exists(centres_path):
        centres = np.loadtxt(centres_path)
    else:
        os.makedirs(kernel_centre_prefix, exist_ok=True)
        centres = np.apply_along_axis(lambda dim_bounds: np.random.uniform(*dim_bounds, num_centers), 1,
                                      set_of_interest_dimension_bounds).T
        np.savetxt(centres_path, centres)

    # Defining the dictionary of functions used for approximating the eigenfunctions
    dict_step = [
        (
            "rbf",
            TSCRadialBasis(
                kernel=ThinPlateKernel(delta=delta), center_type="fit_params"
            )
        ),
        (
            "id",
            TSCIdentity(include_const=True, rename_features=False)
        ),
    ]

    # Fitting the EDMD approximation of the Koopman operator
    edmd = EDMD(dict_steps=dict_step, include_id_state=True).fit(
        X=dataset,
        rbf__centers=centres
    )
    return edmd


def label_basin_data(koopman_approximation, dimensions, num_points_per_dim, epsilon=1e-2):
    """
    Labels the state space of the dynamical system approximated by the Koopman operator according to the cluster it
    belongs to. For determining cluster membership the eigenfunctions of eigenvalues close to 1 are evaluated and the
    results clustered using k-means.

    :param koopman_approximation:   EDMD, Approximation of the Koopman operator
    :param dimensions:              [(lower_bound, upper_bound)], List of lower bound and upper bound values for each
                                                                  dimension of the state space.
    :param num_points_per_dim:      int, Number of points per dimension, points will be chosen equidistantly.
    :param epsilon:                 float, Tolerance up to which an eigenvalue is considered to be close to 1.
    :return:                        numpy.array(shape=(num_points_per_dim**len(dimensions), )), Labels for each datapoint.
    """
    # First, get the datapoints of the state space
    d_eval = generate_sample_points(dimensions, num_points_per_dim)

    # Transform the set of points in state space into a TSCDataFrame for evaluation of the eigenfunctions
    df_list = []
    for point in d_eval:
        df = pd.DataFrame(columns=koopman_approximation.feature_names_in_, dtype=float)
        df.loc[0, :] = point
        df_list.append(df)
    tsc_data = TSCDataFrame.from_frame_list(df_list)

    # Find the eigenfunctions to eigenvalues close to 1
    distance_to_one = np.abs(koopman_approximation.koopman_eigenvalues.array - 1)
    sorted_indices = np.argsort(distance_to_one)
    indices = np.argwhere(distance_to_one < epsilon)
    # Cut the list at 10, in order to allow for reasonable visual representation, exact value can be changed
    if len(indices) > 10:
        indices = sorted_indices[:10]
    else:
        indices = indices.reshape((-1))
    # Make sure we have an upper limit for the number of clusters
    n_1 = len(indices)

    # Evaluate the eigenfunctions and select the evaluations of eigenfunctions to eigenvalues close to 1
    eigenfunction_evaluation = koopman_approximation.koopman_eigenfunction(tsc_data)
    d_basins = eigenfunction_evaluation.loc[:, eigenfunction_evaluation.columns[indices]]
    d_basins_values = d_basins.values

    # Split up complex values into real and imaginary part and convert it into one array again
    real_func = np.vectorize(lambda x: x.real)
    im_func = np.vectorize(lambda x: x.imag)
    real_values = real_func(d_basins_values)
    im_values = im_func(d_basins_values)
    decomplexed_values = np.concatenate([real_values, im_values], axis=1)

    # Run k-means for clustering
    labels = KMeans(n_clusters=n_1).fit_predict(decomplexed_values)

    return labels


def run_experiment(data_name, dyn_sys_parameter_dict):
    """
    Runs a single experiment defined by the name of the dataset and the parameters for the dynamical system.

    :param data_name:               str, Name of the dataset on which the Koopman operator will be trained.
    :param dyn_sys_parameter_dict:  dict, Dictionary containing the parameters of the dynamical system.
    :return:                        None
    """
    # Load the dataset
    data_snap = load(data_name, dyn_sys_parameter_dict)

    # Calculate an approximation of the Koopman operator
    koopman_approximation = approximate_koopman(data_name, dyn_sys_parameter_dict['dimensions'], data_snap)

    # Save the modes of the Koopman operator
    save_koopman_modes_path(koopman_approximation.koopman_modes, data_name, dyn_sys_parameter_dict)

    # Cluster and label points in the domain based on the evaluations of selected Koopman eigenfunctions
    labels = get_cluster_labels(koopman_approximation, data_name, dyn_sys_parameter_dict)

    # Simple plotting of the basins
    plot_basins(data_name, dyn_sys_parameter_dict, labels)


def save_koopman_modes_path(koopman_modes, data_name, dyn_sys_parameter_dict):
    """
    Simple helper to save the modes of the Koopman operator.

    :param koopman_modes:           numpy array, Koopman modes
    :param data_name:               str, Name of the dataset from which the dynamical system is derived.
    :param dyn_sys_parameter_dict:  dict, Dictionary of arguments defining the dynamical system.
    :return:                        None
    """
    # Generate the path based on data name and parameters
    koopman_modes_path = os.path.join(results_prefix, data_name + '_koopman_modes_' + '_'.join(
        [str(key) + ':' + str(value) for key, value in dyn_sys_parameter_dict.items()]) + '.csv')

    # Only save the modes if they have not yet been saved by a previous run
    if not os.path.exists(koopman_modes_path):
        os.makedirs(results_prefix, exist_ok=True)
        koopman_modes.to_csv(koopman_modes_path)


def get_cluster_labels(koopman_approximation, data_name, dyn_sys_parameter_dict):
    """
    Cluster and label the points in parameter space of the algorithm defining the dynamical system.
    Previously generated results will be loaded if possible.

    :param koopman_approximation:       EDMD, Approximation of the Koopman operator
    :param data_name:                   str, Name of the dataset on which the dynamical system operates
    :param dyn_sys_parameter_dict:      dict, Parameter dictionary defining the dynamical system
    :return:                            numpy.array, Labels to each datapoint in parameter space
    """
    # Defining the path, so we can load if possible
    labels_path = os.path.join(results_prefix, data_name + '_labels_' + '_'.join(
        [str(key) + ':' + str(value) for key, value in dyn_sys_parameter_dict.items()]) + '.csv')

    # Load labels from file if possible, otherwise generate new labels and save them to file
    if os.path.exists(labels_path):
        labels = np.loadtxt(labels_path)
    else:
        labels = label_basin_data(koopman_approximation, dyn_sys_parameter_dict['dimensions'],
                                  dyn_sys_parameter_dict['num_points_per_dim'])
        np.savetxt(labels_path, labels)

    return labels
